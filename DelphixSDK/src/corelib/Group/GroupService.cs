using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using RestSharp;
using NLog;
using Newtonsoft.Json;
using RestSharp.Serialization;
using Newtonsoft.Json.Linq;
using System.Threading;
using System.Net;

using DelphixLibrary.Authentication;

namespace DelphixLibrary.Group
{
    public class GroupService
    {
        private static Logger logger = LogManager.GetCurrentClassLogger();
        
        public GetGroupsResponse GetGroups() {
            //string groups = "";
            var request = new RestRequest("resources/json/delphix/group", Method.GET);
            //request.RequestFormat = DataFormat.Json;
            //request.AddBody(body);
            request.AddHeader("content-header", "application/json");
            request.AddCookie(Session.jSessionId.Name, Session.jSessionId.Value);
            try
            {
                var result = Session.delphixClient.Get(request);
                string dbs = result.Content;
                var response = JsonConvert.DeserializeObject<GetGroupsResponse>(dbs);
                if (response.status.Equals("OK"))
                {
                    var deserializedDbs = response.result;
                    logger.Info(deserializedDbs.ToString());
                    //return deserializedDbs;
                    return response;
                }
                else
                {
                    logger.Warn("The response was NOT OK GetEnvironments: " + response.result);
                    throw new Exception("The status returned from the GetEnvironments call was NOT OK");
                }
            }
            catch (Exception ex)
            {
                logger.Error("There was an error running GetEnvironments:" + ex);
                throw ex;
            }

        }

        //not finished
        public CreateGroupsResponse CreateGroups(string groupName, bool force = false)
        {
            dynamic ProvisionParameters = new JObject();
            ProvisionParameters.type = "Group";
            ProvisionParameters.name = groupName;
            ProvisionParameters.description = "Generated by UtilityMultiRestore";

            ProvisionParameters = JsonConvert.SerializeObject(ProvisionParameters);
            var request = new RestRequest("resources/json/delphix/group", Method.POST);
            request.RequestFormat = DataFormat.Json;
            request.AddBody(ProvisionParameters);

            request.AddHeader("content-header", "application/json");
            request.AddCookie(Session.jSessionId.Name, Session.jSessionId.Value);
            var result = Session.delphixClient.Post(request);
            string groups = result.Content;
            var response = JsonConvert.DeserializeObject<CreateGroupsResponse>(groups);
            if (response.status.Equals("OK"))
            {
                var deserializedDbs = response.result;
                logger.Info(deserializedDbs.ToString());

                //return deserializedDbs;
                return response;
            }
            if (response.status.Equals("ERROR"))
            {
                switch (force) {
                    case true:
                        logger.Warn("Attempting to force group creation... Deleting old group");
                        DelphixGroup grp = GetGroupByGroupName(groupName);
                        DeleteGroups(grp.reference);
                        Thread.Sleep(10000);
                        return CreateGroups(groupName);
                    case false:
                        logger.Error(response.result);
                        //return "Group already exists";
                        return response;
                }
            }

            else
            {
                Console.WriteLine("The status returned from the CreateGroup call was NOT OK");
                return response;
            }
            return response;

        }

        public string DeleteGroups(string groupRef)
        {
            var request = new RestRequest("resources/json/delphix/group/" + groupRef, Method.DELETE);

            request.AddHeader("content-header", "application/json");
            request.AddCookie(Session.jSessionId.Name, Session.jSessionId.Value);
            var result = Session.delphixClient.Delete(request);
            string groups = result.Content;
            var response = JsonConvert.DeserializeObject<CreateGroupsResponse>(groups);
            if (response.status.Equals("OK"))
            {
                var deserializedDbs = response.result;
                logger.Info(deserializedDbs.ToString());

                return deserializedDbs;
            }
            if (response.status.Equals("ERROR"))
            {
                logger.Error(response.result);
                return "Group already exists";
            }

            else
            {
                Console.WriteLine("The status returned from the DeleteGroup call was NOT OK");
                return "";
            }


        }

        public DelphixGroup GetGroupByGroupName(string groupName) {
            List<DelphixGroup> groups = GetGroups().result;
            foreach (DelphixGroup delphixDb in groups)
            {
                groupName = groupName.ToUpper();
                if (delphixDb.name.ToString().ToUpper().Equals(groupName))
                {
                    logger.Info("Found a match for " + groupName + "- RefId:" + delphixDb.reference.ToString() + " Name:" + delphixDb.name.ToString());
                    return delphixDb;
                }
            }
            throw new Exception("No group found matching that group name");
        }

        public Dictionary<String,String> GetGroupInfo(string jsonResponse) {
            Dictionary<String, String> groupDict = new Dictionary<string, string>();
            dynamic data = JObject.Parse(jsonResponse);
            //Console.WriteLine(data.result[1]);
            //dynamic dynJson = JsonConvert.SerializeObject(data.result);

            for (int i = 0; i < data.result.Count ; i++) {
                Console.WriteLine(data.result[i]);
                groupDict.Add(data.result[i].name.ToString(), data.result[i].reference.ToString());
            }

            return groupDict;

        }
    }
}
